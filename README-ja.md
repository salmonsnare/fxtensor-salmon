# FXTensor

FXTensorは、テンソルベースの計算を行うためのPythonライブラリです。特に、圏論に基づいたシステムやプロセスのモデルに見られるような、確率的なシステムを表現し操作するのに適しています。効率的な数値計算のためにNumPyを使用しています。

## 中核となる概念

FXTensorにおけるテンソルは、その `profile` と `data` によって定義されます。

- **プロファイル (Profile)**: `[domain, codomain]` というリストのペアで、テンソルの入力および出力インデックスの次元を指定します。例えば、`[[2], [3]]` は2x3の行列を表します。
- **データ (Data)**: テンソルの値を保持するNumPy配列です。配列の軸の数は、プロファイル内の次元の総数（domainの長さ + codomainの長さ）と一致する必要があります。

## 単純な例：天気予報

天候が **晴れ (0)** または **雨 (1)** のいずれかである単純な天候システムをモデル化してみましょう。

- **状態テンソル**: 現在の天気の確率を表します。もし今日が晴れであることが確実なら、状態は `[1, 0]` となります。このテンソルは、空のdomain `[]` と `[2]` のcodomainを持ちます。

  ```python
  # P(Weather=Sunny) = 1, P(Weather=Rainy) = 0
  sunny_today = FXTensor([[], [2]], data=np.array([1, 0]))
  ```

- **プロセス・テンソル**: 天気予報のような確率的なプロセスを表します。これは、行が今日の天気、列が明日の天気を示す行列です。

  ```python
  # P(Tomorrow | Today)
  forecast_matrix = np.array([
      [0.8, 0.2], # Today is Sunny -> Tomorrow is P(Sunny)=0.8, P(Rainy)=0.2
      [0.4, 0.6]  # Today is Rainy -> Tomorrow is P(Sunny)=0.4, P(Rainy)=0.6
  ])
  forecast_tensor = FXTensor([[2], [2]], data=forecast_matrix)
  ```

- **合成 (Composition)**: 今日の状態と予報テンソルを合成することで、明日の天気を予測できます。

  ```python
  # 結果は明日の天気の確率を表す新しい状態テンソル
  sunny_tomorrow = sunny_today.composition(forecast_tensor)
  # sunny_tomorrow.data -> np.array([0.8, 0.2])
  ```

## 発展的な例：多次元システム

次に、より複雑なシステム、すなわち **場所 (Location)** を与えられたときの **季節 (Season)** と **天気 (Weather)** の同時確率を考えてみましょう。

- **Domain**: 場所 `{市街地, 田舎}` (サイズ 2)
- **Codomain**: 季節 `{春, 夏, その他}` (サイズ 3) と 天気 `{晴れ, 雨}` (サイズ 2)

これは、プロファイルが `[[2], [3, 2]]` であるテンソル `P(季節, 天気 | 場所)` で表現できます。

```python
# P(季節, 天気 | 場所) を表すテンソル
# データは形状が (2, 3, 2) の3次元NumPy配列
# 簡単のため、ここではプレースホルダーデータを使用
process_data = np.random.rand(2, 3, 2)
# codomain軸の合計が1になるように正規化し、有効なマルコフテンソルにする
process_data /= process_data.sum(axis=(1, 2), keepdims=True)

process_tensor = FXTensor([[2], [3, 2]], data=process_data)
```

## `FXTensor` の主要メソッドの実践

この `process_tensor` を使って、主要なメソッドがどのように機能するかを見ていきましょう。

#### `marginalization(start_B)`
このメソッドは、与えられたインデックス `start_B`（1から始まる）*から* codomainの軸に沿って合計します。

```python
# 元のプロファイル: [[2], [3, 2]] -> P(季節, 天気 | 場所)
# 天気を合計して消去し、P(季節 | 場所) を得たい
# 「天気」の部分はcodomainの2番目の要素から始まる
season_tensor = process_tensor.marginalization(start_B=2)

# 結果のプロファイル: [[2], [3]]
# 結果のデータ形状: (2, 3)
```

#### `discard_prefix(start_B)`
このメソッドは、与えられたインデックス `start_B` *より前* のcodomainの軸に沿って合計します。

```python
# 元のプロファイル: [[2], [3, 2]] -> P(季節, 天気 | 場所)
# 季節を合計して消去し、P(天気 | 場所) を得たい
# 「季節」の部分が、消去したいプレフィックス
weather_tensor = process_tensor.discard_prefix(start_B=2)

# 結果のプロファイル: [[2], [2]]
# 結果のデータ形状: (2, 2)
```

#### `conditionalization(start_B)`
テンソルのスライスを正規化することにより、条件付き確率を計算します。

```python
# 元のプロファイル: [[2], [3, 2]] -> P(季節, 天気 | 場所)
# P(天気 | 場所, 季節) を計算したい
# これには、各「場所」と「季節」に対してデータを正規化する必要がある
cond_tensor = process_tensor.conditionalization(start_B=2)

# 結果のプロファイル: [[2, 3], [2]]
# 結果のデータ形状: (2, 3, 2)
```

#### `tensor_product(other)`
2つの独立したシステムを結合します。

```python
# 別のシステムを導入：P(交通量) ここで交通量は {少ない, 多い}
# これはプロファイルが [[], [2]] の状態テンソル
traffic_state = FXTensor([[], [2]], data=np.array([0.7, 0.3]))

# テンソル積は、同時確率 P(季節, 天気, 交通量 | 場所) を与える
joint_tensor = process_tensor.tensor_product(traffic_state)

# 結果のプロファイル: [[2], [3, 2, 2]]
# 結果のデータ形状: (2, 3, 2, 2)
```

## 理論的背景：マルコフ圏との関係

本ライブラリ `fxtensor-salmon` の設計は、圏論的確率論の枠組みである**マルコフ圏 (Markov Category)** の概念に深く根ざしています。特に、檜山正幸氏のブログ記事「マルコフ圏 A First Look」および「マルコフ圏におけるテンソル計算の手順とコツ」で解説されている用語や考え方は、本ライブラリの機能を理解する上で重要な指針となります。このセクションでは、これらの記事で述べられている概念と、`FXTensor` の具体的な実装との対応関係を解説します。

### マルコフ圏の基本要素とFXTensor

マルコフ圏は、確率的なシステムを抽象的に扱うための数学的構造です。その主要な構成要素は「対象」と「射」です。

- **対象 (Object)**: マルコフ圏における「対象」は、確率変数が値を取りうる**状態空間**を表します。これは、より厳密には可測空間 `(X, ΣX)` として定義されます。`FXTensor` の文脈では、我々は有限離散空間のみを扱うため、対象は単純に次元のリスト、例えば `[2]` や `[3, 2]` によって表現されます。`[2]` は `{0, 1}` という2つの要素を持つ状態空間を、`[3, 2]` は `{0, 1, 2}` と `{0, 1}` という2つの状態空間の**モノイド積 (tensor product)** `3 ⊗ 2` によって構成される合成状態空間を表します。

- **射 (Morphism)**: 「射」`f: A -> B` は、状態空間 `A` から `B` への**確率的な遷移**、すなわち**マルコフ核 (Markov kernel)** を表します。これは、入力 `a ∈ A` が与えられるたびに、出力空間 `B` 上の確率分布を一つ定める関数です。`FXTensor` インスタンスそのものが、この「射」の具体的な表現です。テンソルの `profile` `[domain, codomain]` は、それぞれ射の始域と終域の対象に対応します。例えば、`FXTensor([[2], [3]])` は、対象 `2` から対象 `3` への射であり、その実体は `(2, 3)` の形状を持つ確率行列（マルコフ行列）として `data` 属性に格納されます。

### 圏論的操作とFXTensorメソッド

マルコフ圏における基本的な操作は、FXTensorのメソッドとして実装されています。

1.  **合成 (Composition)**: `f: A -> B` と `g: B -> C` という2つの射の合成 `f ; g` は、プロセスを連続して実行することに対応します。これは `t1.composition(t2)` メソッドによって実現されます。ストリング図では、`f` の出力ワイヤーと `g` の入力ワイヤーを接続する操作に相当し、計算上はテンソルの縮約（行列の積の一般化）が実行されます。

2.  **モノイド積 (Tensor Product)**: `f: A -> B` と `g: C -> D` という2つの独立した射を並べて、新しい射 `f ⊗ g: A ⊗ C -> B ⊗ D` を作る操作です。これは `t1.tensor_product(t2)` に対応します。これにより、独立したシステムを結合して、より大きな複合システムをモデル化できます。ストリング図では、2つの図を横に並べる操作に相当します。

3.  **特殊な射：破棄と複製**
    - **破棄 (Discard)**: `!: A -> I` は、状態空間 `A` の情報を完全に無視する射です（`I` は1次元の終対象）。これは、確率分布を周辺化（marginalize）する操作に他なりません。`marginalization(start_B)` と `discard_prefix(start_B)` は、この「破棄」の概念を実装したものです。codomainの一部（特定の出力ワイヤー）を合計して消去することにより、その部分に対応する情報を破棄した新しい射を生成します。
    - **複製 (Copy)**: `Δ: A -> A ⊗ A` は、状態を複製する射です。これは `FXTensor.delta(dims)` によって生成されます。重要なのは、この操作が決定性（deterministic）であるという点です。確率的な値を複製することは、一般には独立性を仮定しない限り意味を成しません。`delta` テンソルは、入力 `i` を `(i, i)` に写すような、対角線上にのみ値を持つ決定性テンソルです。

### 確率的性質とFXTensor

檜山氏のブログで強調されているように、マルコフ圏の射は「規格化条件」を満たします。これは、各入力に対して、出力全体の確率の合計が1になるという条件です。

- `is_markov()`: このメソッドは、与えられたテンソルがこの規格化条件を満たしているか、すなわち有効なマルコフ核であるかを判定します。
- `is_deterministic()`: 射が決定性であるとは、各入力に対して出力が確率1で一意に定まる場合を指します。このメソッドは、テンソルがこの性質を持つか（各行に1が一つだけで、他は0であるか）を検証します。

### テンソル計算とストリング図

「マルコフ圏におけるテンソル計算の手順とコツ」の記事では、ストリング図とテンソル計算の対応が詳しく解説されています。`FXTensor` の操作は、まさにこのストリング図の操作を代数的に実行していると解釈できます。

- **プロファイルの `domain` と `codomain`**: それぞれストリング図の入力ワイヤーと出力ワイヤーの束に対応します。リスト内の各数値が個々のワイヤーの次元です。
- **`composition`**: 図を縦に接続します。
- **`tensor_product`**: 図を横に並べます。
- **`marginalization`**: 出力ワイヤーの一部を途中で終端させ、その影響を合計して消し去ります。

このように、`fxtensor-salmon` は、マルコフ圏という強力な理論的背景を持つ抽象的な概念を、NumPyベースの具体的なテンソル計算として実装したライブラリです。ストリング図で描かれる直感的なプロセス操作を、厳密かつ効率的に実行するための計算ツールとして設計されています。

## テスト

このプロジェクトでは、テストに `pytest` を使用しています。テストは `tests/test_fxtensor.py` 内で、関連する機能をグループ化するためにクラスにまとめられています。

テストを実行するには、プロジェクトのルートから以下のコマンドを実行してください:

```bash
pytest
```

## 参考文献
- [1] 檜山正幸のキマイラ飼育記 (はてなBlog), マルコフ圏 A First Look -- 圏論的確率論の最良の定式化](https://m-hiyama.hatenablog.com/entry/2020/06/09/154044)
- [2] 檜山正幸のキマイラ飼育記 (はてなBlog), マルコフ圏におけるテンソル計算の手順とコツ](https://m-hiyama.hatenablog.com/entry/2021/04/05/153325)
